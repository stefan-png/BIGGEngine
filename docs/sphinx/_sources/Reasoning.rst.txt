Reasoning
=========

Coding Patterns
---------------

In this project, there is a lot of global state. This state must be accessible anywhere,
but only accessed and manipulated in specific ways. I needed to hide the raw data, and
expose it only through functions. In other words, I need an Interface_ between the end user
and the systems I create. The two solutions I used are structs with private
``static`` variables in header files and global variables in an anonymous ``namespace`` in
cpp files.

.. _Interface: https://en.wikipedia.org/wiki/Interface_(computing)

Coding Patterns - Header file
-----------------------------

This pattern is used in places like ``Log.hpp``, ``Profile.hpp``.

It is good for things which do not hold a lot of data, and hold mostly functions.
It does not need to be compiled, so it can be included in every file and it mostly just works.
It is also good for templated functions, because templates are easier to use when defined in a header file.

However, using only a header file is not good for larger systems.
It may cause problems when dynamically linked. (ie. there may be two instances of the same state)
It becomes more difficult to write larger systems in one single header file.
Including the file into each subsystem increases compile times for those subsystems. (speculative)

Example:

.. code:: c++

    // Profile.hpp

    struct Profile {

        Profile() = delete; // cannot instantiate this struct

    public: // public function to access / manipulate data

        static inline double now() {
            return (double) (getPlatformTime() - s_offset) / s_frequency ;
        }

    private: // helper functions

        static uint64_t getPlatformTime() {
            /* ... */
        }

        static uint64_t getPlatformFrequency() {
            /* ... */
        }

        static uint64_t getPlatformClockID() {
            /* ... */
        }

    private: // private state

        // initialized inline with function so that it can be const. (it doesn't change over the course of the program)
        static const inline uint64_t s_offset = getPlatformTime();
        static const inline uint64_t s_frequency = getPlatformFrequency();
        static const inline uint64_t s_clockid = getPlatformClockID();
    };

.. _CodingPatternsAnonymousNamespace:

Coding Patterns - anonymous namespace
-------------------------------------

This pattern is used in ``Context.*``, ``Events.*``, ``RenderBase.*``, ``RenderUI.*``, ``Script.*``.

It is easier to organize systems which are more complex, because things can be separated into a
header file and a cpp file.
It only needs to be compiled into a ``.o`` file once, decreasing compile times for larger systems. (speculative)
It behaves better when dynamically linked. (I hope)

In the header file, I declare the functions the user will use to access / manipulate the global data.
In the cpp file, I define them. I use an anonymous namespace (``namespace { /* ... */ }``) to declare
global variables and helper functions. The anonymous namespace makes the variables invisible to other
translation units, so the user cannot access the data directly.

This method is sometimes better because there are just functions instead of static member functions.
This makes it more clear about the purpose of the functions, are reduces the need for 'manager' functions.

Example:

.. code:: c++

    // RenderBase.hpp
    // just declare the public functions
    void init();

    // RenderBase.cpp
    namespace { // begin anonymous namespace. Anything defined here is not accessible outside this translation unit.

        // private global state
        uint32_t resetFlags = BGFX_RESET_VSYNC | BGFX_RESET_MSAA_X16;

        // private helper functions
        bool handleWindowCreateEvent(WindowCreateEvent){
            /* ... */
        }
        bool handleWindowSizeEvent(WindowSizeEvent event) {
            /* ... */
        }
        bool handleLateUpdateEvent(UpdateEvent) {
            /* ... */
        }
    }   // end anonymous namespace

    // public functions are defined outside
    void init() {
        BIGG_PROFILE_INIT_FUNCTION;

        Events::subscribe<WindowCreateEvent>(g_renderBaseBeginPriority, handleWindowCreateEvent);
        Events::subscribe<WindowSizeEvent>(g_renderBaseBeginPriority,   handleWindowSizeEvent);
        Events::subscribe<UpdateEvent>(g_renderBaseEndPriority,         handleLateUpdateEvent);
    }



Events system
-------------

The events system is templated to work with any type of event. Therefore,
there is the following *for each event type T:*

- A ``std::map`` 'callbacks'. The key is an integer, priority, and the value is an EventFunctor of type ``functor_t`` which by default:

.. _functor_t:

.. code:: c++

    using functor_t = std::function<bool(T)>;

- A ``T`` 'event'. When an event is published by the window context, it populates this field with the event data. When events are polled, this data is propogated to all the handlers as the argument into functor_t_.

- A ``bool`` 'handled'.

The interface functions (functions the user can use) for Events are defined in the
file ``Events.hpp``. They include:

.. code:: c++

    // Events.hpp
    bool subscribe(uint16_t priority, functor_t<Event> &&functor);
    bool unsubscribe(uint16_t priority);
    void setEvent(Event &&event);
    void pollEvent();
    void pollEvents();
    void reset();

Some events, like ``WindowSize``, are both posted by the window context and
handled by the context. That is, they are both incoming and outgoing
events. Therefore, their implementation is more complex. The context
must determine if the polled event was one it just posted or if it is an incoming
request from the user. It does this by comparing the event's data to the current state.

.. code:: c++

    // ContextImplGLFW.cpp

    bool GLFWContext::handleWindowSize(WindowSizeEvent event) {
        if(GLFWContext::getWindowSize() == event.m_size) {
            // window size is equal to current size. This event
            // was posted by the context last frame.
            return false;
        }
        // window size is not equal to current size. This
        // event was posted by the user.
        glfwSetWindowSize(window, event.m_size.x, event.m_size.y);
        return true; 
    }

A consequence of this is some events block the main thread (at least on macos).
For instance, resizing the window freezes the running thread. Since the main
thread is blocked, no events are polled, but resize events are still 
continuously being queued! Once the user lets go, all the events are handled
in FIFO order. However, getWindowSize() returns the actual size of the window,
and the final size of the window will be different than the first ``resizeEvent``.
In ``handleWindowSize()``, this would be interpreted as a user request to resize
the window and the window would be resized, posting an event to the end of the 
queue. This repeats forever, freezing the program.

One solution is to recursively call ``pollEvents()`` inside the implementation
callback. This works, but it might be possible to get a stack overflow error 
if the events are too heavy and they recurse for too long. 

Instead, it would be sufficient to only store one ``ResizeEvent`` per frame 
and simply reassign it on each event. Then, once the main thread regains 
polling, propogate only one events, the most recent one, to the program.
With this, the application would only recieve a resize event once the user
releases the mouse. It may still be necesarry to store many ``WindowCreate``
and ``WindowDestroy`` events since the user may want to create/WindowDestroy
many events per frame, and not just the most recent one. Same with all other
"handle" events which are strictly incoming.

It is also possible to simply have a ``createWindow()``, ``setWindowSize()``, 
etc. functions and not deal with all this.

Profile and Log static classes
--------------------------------------

Both the ``Profile`` and ``Log`` classes are entirely static. They have no
constructor, init, or shutdown functions. They are basically a namespace. Both
classes are intended to exist for the entire lifespan of the program, therefore
I didn't think explicit construction / destruction was necessary. Both classes
are essentially just a few functions and a bit of constant state. Note: ``Log.hpp``
contains some dynamic state: the name of the logger depends on the implementation.

The reason these classes are not namespaces is because they have private variables.
In ``Log.hpp``, the individual loggers should be private. My intention is that users
call the macros ``BIGG_LOG_xxxx``, and not the member loggers, but it is possible, 
which isn't exactly ideal.


